# coding=utf-8

import math
from PyQt5 import QtCore
from kataja.KatajaAction import KatajaAction
from kataja.saved.Edge import Edge

from kataja.singletons import ctrl, log


# ==== Class variables for KatajaActions:
#
# k_action_uid : unique id for calling this action. required, other are optional
# k_command : text used for menu command and log feedback, unless the method returns a fdback string
# k_tooltip : tooltip text for ui element. If not given, uses k_command as tooltip.
# k_undoable : is the action undoable, default is True
# k_shortcut : keyboard shortcut given as string, e.g. 'Ctrl+x'
# k_shortcut_context : can be nothing or 'parent_and_children' if shortcut is active only when the
#                      parent widget is visible and active
# k_dynamic : if True, there are many instances of this action with different ids, generated by
#             code, e.g. visualisation1...9
# k_checkable : should the action be checkable, default False
# k_exclusive : use together with k_dynamic, only one of the instances can be checked at time.
#
# ==== Methods:
#
# method : gets called when action is triggered. If it returns a string, this is used as a command
#          feedback string, otherwise k_command is printed to log.
# getter : if there is an UI element that can show state or display value, this method returns the
#          value. These are called quite often, but with values that have to change e.g. when item
#          is dragged, you'll have to update manually.
# enabler : if enabler is defined, the action is active (also reflected into its UI elements) only
#           when enabler returns True
#

class EditEdgeLabelEnterText(KatajaAction):
    k_action_uid = 'edit_edge_label_enter_text'
    k_command = 'Enter'
    k_shortcut = 'Return'
    k_shortcut_context = 'parent_and_children'

    def method(self):
        """ Accept & update changes to edited edge label
        :return None:
        """
        embed = self.get_ui_container()
        if embed:
            embed.host.set_label_text(embed.input_line_edit.text())
        ctrl.ui.close_active_embed()


class DisconnectEdgeStart(KatajaAction):
    k_action_uid = 'disconnect_edge_start'
    k_command = 'Disconnect edge from start'

    def method(self):
        """ Remove connection between two nodes, this is triggered from the edge.
        :return: None
        """
        # Find the triggering edge
        button = self.get_ui_container()
        if not button:
            return
        edge = button.host
        if not edge:
            return
        # Then do the cutting
        if edge.delete_on_disconnect():
            ctrl.forest.disconnect_edge(edge)
        else:
            ctrl.forest.partial_disconnect(edge, start=True, end=False)
        ctrl.ui.update_selections()


class DisconnectEdgeEnd(KatajaAction):
    k_action_uid = 'disconnect_edge_end'
    k_command = 'Disconnect edge from end'

    def method(self):
        """ Remove connection between two nodes, this is triggered from the edge.
        :return: None
        """
        # Find the triggering edge
        button = self.get_ui_container()
        if not button:
            return
        edge = button.host
        if not edge:
            return
        # Then do the cutting
        if edge.delete_on_disconnect():
            ctrl.forest.disconnect_edge(edge)
        else:
            ctrl.forest.partial_disconnect(edge, start=False, end=True)
        ctrl.ui.update_selections()


class NewArrow(KatajaAction):
    k_action_uid = 'new_arrow'
    k_command = 'New arrow'
    k_shortcut = 'a'
    k_shortcut_context = 'parent_and_children'

    def method(self):
        """ Create a new arrow into embed menu's location
        """
        embed = self.get_ui_container()
        p1, p2 = embed.get_marker_points()
        text = embed.input_line_edit.text()
        ctrl.forest.create_arrow(p2, p1, text)
        ctrl.ui.close_active_embed()


class StartArrowFromNode(KatajaAction):
    k_action_uid = 'start_arrow_from_node'
    k_command = 'Add arrow from here to...'
    # k_shortcut = 'a'
    # k_shortcut_context = 'parent_and_children'

    def method(self):
        """
        :return:
        """
        button = self.get_ui_container()
        if not button:
            return
        node = button.host
        ex, ey = node.bottom_center_magnet()
        end_pos = QtCore.QPointF(ex + 20, ey + 40)
        ctrl.forest.create_arrow_from_node_to_point(node, end_pos)


class DeleteArrow(KatajaAction):
    k_action_uid = 'delete_arrow'
    k_command = 'Delete arrow'

    def method(self):
        button = self.get_ui_container()
        if not button:
            return
        edge = button.host
        if not edge:
            return
        # Then do the cutting
        ctrl.forest.disconnect_edge(edge)
        ctrl.ui.update_selections()


class NewDivider(KatajaAction):
    k_action_uid = 'new_divider'
    k_command = 'New divider'
    k_shortcut = 'd'
    k_shortcut_context = 'parent_and_children'

    def method(self):
        """ Create a new divider into embed menu's location
        """
        embed = self.get_ui_container()
        p1, p2 = embed.get_marker_points()
        ctrl.ui.close_active_embed()
        # fixme: finish this!


# Edge settings

class ChangeEdgeShape(KatajaAction):
    k_action_uid = 'change_edge_shape'
    k_command = 'Change edge shape'
    k_tooltip = 'Change shapes of lines between objects'
    k_undoable = False

    def method(self):
        """ Change edge shape for selection or in currently active edge type.
        :return: None
        """
        sender = self.sender()
        shape = sender.currentData()

        if ctrl.ui.scope_is_selection:
            for edge in ctrl.selected:
                if isinstance(edge, Edge):
                    edge.shape_name = shape
                    edge.update_shape()
        else:
            ctrl.fs.set_edge_info(ctrl.ui.active_edge_type, 'shape_name', shape)
            for edge in ctrl.forest.edges.values():
                edge.update_shape()
        line_options = ctrl.ui.get_panel('LineOptionsPanel')

        if line_options:
            line_options.update_panel()
        log.info('(s) Changed relation shape to: %s' % shape)

    def enabler(self):
        if ctrl.ui.scope_is_selection:
            for edge in ctrl.selected:
                if isinstance(edge, Edge):
                    return True
            return False
        return True  # all scope options allow defining edge shape

    def getter(self):
        return ctrl.ui.active_edge_style.get('shape_name', None)


class ChangeEdgeColor(KatajaAction):
    k_action_uid = 'change_edge_color'
    k_command = 'Change edge color'
    k_tooltip = 'Change drawing color for edges'
    k_undoable = False

    def method(self):
        """ Change edge shape for selection or in currently active edge type.
        :return: None
        """
        panel = ctrl.ui.get_panel('StylePanel')
        color_key = panel.edge_color_selector.currentData()
        panel.edge_color_selector.model().selected_color = color_key
        color = ctrl.cm.get(color_key)
        # launch a color dialog if color_id is unknown or clicking
        # already selected color
        prev_color = panel.cached_edge_color
        if not color:
            color = ctrl.cm.get('content1')
            ctrl.cm.d[color_key] = color
            ctrl.ui.start_color_dialog(panel.edge_color_selector, panel, 'edge', color_key)
        elif prev_color == color_key:
            ctrl.ui.start_color_dialog(panel.edge_color_selector, panel, 'edge', color_key)
        else:
            ctrl.ui.update_color_dialog('edge', color_key)
        panel.update_edge_color_selector(color_key)
        # Update color for selected edges
        if ctrl.ui.scope_is_selection:
            for edge in ctrl.selected:
                if isinstance(edge, Edge):
                    edge.color_id = color_key
                    edge.update()
        # ... or update color for all edges of this type
        else:
            ctrl.fs.set_edge_info(ctrl.ui.active_edge_type, 'color', color_key)
            for edge in ctrl.forest.edges.values():
                edge.update()
        if color_key:
            log.info('(s) Changed relation color to: %s' % ctrl.cm.get_color_name(color_key))

    def getter(self):
        return ctrl.ui.active_edge_style.get('color')


class ControlPoint1Dist(KatajaAction):
    k_action_uid = 'control_point1_dist'
    k_command = 'Adjust curvature, point 1 distance'

    def method(self):
        """ Adjust specifix control point
        :return: None
        """
        value = self.state_arg
        if value is None:
            return
        for edge in ctrl.selected:
            if isinstance(edge, Edge):
                edge.shape_info.adjust_control_point(0, dist=value * 0.01)

    def enabler(self):
        return ctrl.ui.scope_is_selection and ctrl.ui.active_edge_style.get('control_points', 0)

    def getter(self):
        ca = ctrl.ui.active_edge_style.get('curve_adjustment', [])
        if ca:
            return round(ca[0][0] * 100)
        else:
            return 0


class ControlPoint2Dist(KatajaAction):
    k_action_uid = 'control_point2_dist'
    k_command = 'Adjust curvature, point 2 distance'

    def method(self):
        """ Adjust specifix control point
        :return: None
        """
        value = self.state_arg
        if value is None:
            return
        for edge in ctrl.selected:
            if isinstance(edge, Edge):
                edge.shape_info.adjust_control_point(1, dist=value * 0.01)

    def enabler(self):
        return ctrl.ui.scope_is_selection and ctrl.ui.active_edge_style.get('control_points', 0) > 1

    def getter(self):
        ca = ctrl.ui.active_edge_style.get('curve_adjustment', [])
        if len(ca) > 1:
            return round(ca[1][0] * 100)
        else:
            return 0


class ControlPoint1Angle(KatajaAction):
    k_action_uid = 'control_point1_angle'
    k_command = 'Adjust curvature, point 1 angle'

    def method(self):
        """ Adjust specifix control point
        :return: None
        """
        value = self.state_arg
        if value is None:
            return
        for edge in ctrl.selected:
            if isinstance(edge, Edge):
                edge.shape_info.adjust_control_point(0, rad=math.radians(value))

    def enabler(self):
        return ctrl.ui.scope_is_selection and ctrl.ui.active_edge_style.get('control_points', 0)

    def getter(self):
        ca = ctrl.ui.active_edge_style.get('curve_adjustment', [])
        if ca:
            return math.degrees(ca[0][1])
        else:
            return 0


class ControlPoint2Angle(KatajaAction):
    k_action_uid = 'control_point2_angle'
    k_command = 'Adjust curvature, point 2 angle'

    def method(self):
        """ Adjust specifix control point
        :return: None
        """
        value = self.state_arg
        if value is None:
            return
        for edge in ctrl.selected:
            if isinstance(edge, Edge):
                edge.shape_info.adjust_control_point(1, rad=math.radians(value))

    def enabler(self):
        return ctrl.ui.scope_is_selection and ctrl.ui.active_edge_style.get('control_points', 0) > 1

    def getter(self):
        ca = ctrl.ui.active_edge_style.get('curve_adjustment', [])
        if len(ca) > 1:
            return math.degrees(ca[1][1])
        else:
            return 0


class ResetControlPoints(KatajaAction):
    k_action_uid = 'reset_control_points'
    k_command = 'Reset control point'
    k_tooltip = 'Remove adjustments for these curves'

    def method(self):
        """ Reset all control points
        :return: None
        """
        for edge in ctrl.selected:
            if isinstance(edge, Edge):
                edge.shape_info.reset_control_points()

    def enabler(self):
        for edge in ctrl.selected:
            if isinstance(edge, Edge):
                if edge.curve_adjustment:
                    for x, y in edge.curve_adjustment:
                        if x or y:
                            return True
        return False


class LeafShapeX(KatajaAction):
    k_action_uid = 'leaf_shape_x'
    k_command = 'Edge shape width'
    k_tooltip = 'Adjust horizontal thickness of edges'

    def method(self):
        """ Change width of leaf-shaped edge.
        """
        value = self.state_arg
        if value is None:
            return
        elif ctrl.ui.scope_is_selection:
            for edge in ctrl.selected:
                if isinstance(edge, Edge):
                    edge.shape_info.set_leaf_width(value)
        else:
            etype = ctrl.ui.active_edge_type
            ctrl.fs.set_shape_info(etype, 'leaf_x', value)
            ctrl.forest.redraw_edges(edge_type=etype)

    def enabler(self):
        return ctrl.ui.active_edge_style.get('fill', False)

    def getter(self):
        return ctrl.ui.active_edge_style.get('leaf_x')


class LeafShapeY(KatajaAction):
    k_action_uid = 'leaf_shape_y'
    k_command = 'Edge shape height'
    k_tooltip = 'Adjust vertical thickness of edges'

    def method(self):
        """ Change height of leaf-shaped edge.
        """
        value = self.state_arg
        if value is None:
            return
        if ctrl.ui.scope_is_selection:
            for edge in ctrl.selected:
                if isinstance(edge, Edge):
                    edge.shape_info.set_leaf_height(value)
        else:
            etype = ctrl.ui.active_edge_type
            ctrl.fs.set_shape_info(etype, 'leaf_y', value)
            ctrl.forest.redraw_edges(edge_type=etype)

    def getter(self):
        return ctrl.ui.active_edge_style.get('leaf_y')


class EdgeThickness(KatajaAction):
    k_action_uid = 'edge_thickness'
    k_command = 'Edge thickness'
    k_tooltip = 'Adjust fixed thickness for edges'

    def method(self):
        """ If edge is outline (not a leaf shape)
        """
        value = self.state_arg
        if value is None:
            return
        if ctrl.ui.scope_is_selection:
            for edge in ctrl.selected:
                if isinstance(edge, Edge):
                    edge.shape_info.change_thickness(value)
        else:
            etype = ctrl.ui.active_edge_type
            ctrl.fs.set_shape_info(etype, 'thickness', value)
            ctrl.forest.redraw_edges(edge_type=etype)

    def enabler(self):
        return ctrl.ui.active_edge_style.get('fill', None) is False

    def getter(self):
        return ctrl.ui.active_edge_style.get('thickness', 0)


class EdgeCurvatureRelative(KatajaAction):
    k_action_uid = 'edge_curvature_relative'
    k_command = 'Change line curvature to be relative to edge dimensions'

    def method(self):
        """ Change curvature computation type. Curvature can be 'relative' or 'fixed'
        """
        value = self.state_arg
        if ctrl.ui.scope_is_selection:
            for edge in ctrl.selected:
                if isinstance(edge, Edge):
                    edge.shape_info.set_edge_curvature_relative(value)
        else:
            etype = ctrl.ui.active_edge_type
            ctrl.fs.set_shape_info(etype, 'relative', value)
            ctrl.forest.redraw_edges(edge_type=etype)

    def enabler(self):
        return ctrl.ui.active_edge_style.get('relative', None) is not None and \
            ctrl.ui.active_edge_style.get('control_points', 0)

    def getter(self):
        return ctrl.ui.active_edge_style.get('relative', None)


class EdgeCurvatureFixed(KatajaAction):
    k_action_uid = 'edge_curvature_fixed'
    k_command = 'Change line curvature to be a pair of fixed values'

    def method(self):
        """ Change curvature computation type. Curvature can be 'relative' or 'fixed'
        """
        value = self.state_arg
        if ctrl.ui.scope_is_selection:
            for edge in ctrl.selected:
                if isinstance(edge, Edge):
                    edge.shape_info.set_edge_curvature_relative(not value)
        else:
            etype = ctrl.ui.active_edge_type
            ctrl.fs.set_shape_info(etype, 'relative', not value)
            ctrl.forest.redraw_edges(edge_type=etype)

    def enabler(self):
        return ctrl.ui.active_edge_style.get('relative', None) is not None and \
            ctrl.ui.active_edge_style.get('control_points', 0)

    def getter(self):
        return not ctrl.ui.active_edge_style.get('relative', None)


class ChangeEdgeRelativeCurvatureX(KatajaAction):
    k_action_uid = 'change_edge_relative_curvature_x'
    k_command = 'Change horizontal curvature for edge'
    k_tooltip = 'Curvature value is relative to edge width'

    def method(self):
        """ Change curvature of arching lines. Curvature is relative to width
        """
        value = self.state_arg
        if value is None:
            return
        if ctrl.ui.scope_is_selection:
            for edge in ctrl.selected:
                if isinstance(edge, Edge):
                    edge.shape_info.change_edge_relative_curvature_x(value)
        else:
            etype = ctrl.ui.active_edge_type
            ctrl.fs.set_shape_info(etype, 'rel_dx', value * .01)
            ctrl.forest.redraw_edges(edge_type=etype)

    def enabler(self):
        return ctrl.ui.active_edge_style.get('relative', False) and \
               ctrl.ui.active_edge_style.get('control_points', 0)

    def getter(self):
        return round(ctrl.ui.active_edge_style.get('rel_dx', 0) * 100)


class ChangeEdgeRelativeCurvatureY(KatajaAction):
    k_action_uid = 'change_edge_relative_curvature_y'
    k_command = 'Change vertical curvature for edge'
    k_tooltip = 'Curvature value is relative to edge height'

    def method(self):
        """ Change curvature of arching lines. Curvature is relative to width
        """
        value = self.state_arg
        if value is None:
            return
        if ctrl.ui.scope_is_selection:
            for edge in ctrl.selected:
                if isinstance(edge, Edge):
                    edge.shape_info.change_edge_relative_curvature_y(value)
        else:
            etype = ctrl.ui.active_edge_type
            ctrl.fs.set_shape_info(etype, 'rel_dy', value * .01)
            ctrl.forest.redraw_edges(edge_type=etype)

    def enabler(self):
        return ctrl.ui.active_edge_style.get('relative', False) and \
               ctrl.ui.active_edge_style.get('control_points', 0)

    def getter(self):
        return round(ctrl.ui.active_edge_style.get('rel_dy', 0) * 100)


class ChangeEdgeFixedCurvatureX(KatajaAction):
    k_action_uid = 'change_edge_fixed_curvature_x'
    k_command = 'Change horizontal curvature for edge'
    k_tooltip = 'Curvature is fixed amount'

    def method(self):
        """ Change curvature of arching lines. Curvature is absolute pixels (X)
        """
        value = self.state_arg
        if value is None:
            return
        if ctrl.ui.scope_is_selection:
            for edge in ctrl.selected:
                if isinstance(edge, Edge):
                    edge.shape_info.change_edge_fixed_curvature_x(value)
        else:
            etype = ctrl.ui.active_edge_type
            ctrl.fs.set_shape_info(etype, 'fixed_dx', value)
            ctrl.forest.redraw_edges(edge_type=etype)

    def enabler(self):
        return ctrl.ui.active_edge_style.get('relative', None) is False and \
               ctrl.ui.active_edge_style.get('control_points', 0)

    def getter(self):
        return ctrl.ui.active_edge_style.get('fixed_dx')


class ChangeEdgeFixedCurvatureY(KatajaAction):
    k_action_uid = 'change_edge_fixed_curvature_y'
    k_command = 'Change vertical curvature for edge'
    k_tooltip = 'Curvature is fixed amount'

    def method(self):
        """ Change curvature of arching lines. Curvature is absolute pixels (X)
        :param value: float
        """
        value = self.state_arg
        if value is None:
            return
        if ctrl.ui.scope_is_selection:
            for edge in ctrl.selected:
                if isinstance(edge, Edge):
                    edge.shape_info.change_edge_fixed_curvature_y(value)
        else:
            etype = ctrl.ui.active_edge_type
            ctrl.fs.set_shape_info(etype, 'fixed_dy', value)
            ctrl.forest.redraw_edges(edge_type=etype)

    def enabler(self):
        return ctrl.ui.active_edge_style.get('relative', None) is False and \
               ctrl.ui.active_edge_style.get('control_points', 0)

    def getter(self):
        return ctrl.ui.active_edge_style.get('fixed_dy')


class EdgeArrowheadStart(KatajaAction):
    k_action_uid = 'edge_arrowhead_start'
    k_command = 'Draw arrowhead at line start'

    def method(self):
        """ Draw arrowheads at start for given edges or edge type
        """
        value = self.state_arg
        if ctrl.ui.scope_is_selection:
            for edge in ctrl.selected:
                if isinstance(edge, Edge):
                    edge.shape_info.set_arrowhead_at_start(value)
        else:
            etype = ctrl.ui.active_edge_type
            ctrl.fs.set_edge_info(etype, 'arrowhead_at_start', value)
            ctrl.forest.redraw_edges(edge_type=etype)
        panel = ctrl.ui.get_panel('LineOptionsPanel')
        if panel:
            panel.update_panel()

    def enabler(self):
        return ctrl.ui.active_edge_style

    def getter(self):
        return ctrl.ui.active_edge_style.get('arrowhead_at_start', False)


class EdgeArrowheadEnd(KatajaAction):
    k_action_uid = 'edge_arrowhead_end'
    k_command = 'Draw arrowhead at line end'

    def method(self):
        """ Draw arrowheads at end for given edges or edge type
        :param value: bool
        """
        value = self.state_arg
        if ctrl.ui.scope_is_selection:
            for edge in ctrl.selected:
                if isinstance(edge, Edge):
                    edge.shape_info.set_arrowhead_at_end(value)
        else:
            etype = ctrl.ui.active_edge_type
            ctrl.fs.set_edge_info(etype, 'arrowhead_at_end', value)
            ctrl.forest.redraw_edges(edge_type=etype)
        panel = ctrl.ui.get_panel('LineOptionsPanel')
        if panel:
            panel.update_panel()

    def enabler(self):
        return ctrl.ui.active_edge_style

    def getter(self):
        return ctrl.ui.active_edge_style.get('arrowhead_at_end', False)


class EdgeShapeFill(KatajaAction):
    k_action_uid = 'edge_shape_fill'
    k_command = 'Set edge to be a filled shape'

    def method(self):
        """ Change edge to draw as filled shape
        """
        if ctrl.ui.scope_is_selection:
            for edge in ctrl.selected:
                if isinstance(edge, Edge):
                    edge.shape_info.change_fill(True)
        else:
            etype = ctrl.ui.active_edge_type
            ctrl.fs.set_shape_info(etype, 'fill', True)
            ctrl.forest.redraw_edges(edge_type=etype)
        panel = ctrl.ui.get_panel('LineOptionsPanel')
        if panel:
            panel.update_panel()

    def enabler(self):
        return ctrl.ui.active_edge_style.get('fill', None) is not None

    def getter(self):
        return ctrl.ui.active_edge_style.get('fill', None)


class EdgeShapeLine(KatajaAction):
    k_action_uid = 'edge_shape_line'
    k_command = 'Set edge to be a fixed width line'

    def method(self):
        """ Change edge to draw as line instead of filled shape
        """
        if ctrl.ui.scope_is_selection:
            for edge in ctrl.selected:
                if isinstance(edge, Edge):
                    edge.shape_info.change_fill(False)
        else:
            etype = ctrl.ui.active_edge_type
            ctrl.fs.set_shape_info(etype, 'fill', False)
            ctrl.forest.redraw_edges(edge_type=etype)
        panel = ctrl.ui.get_panel('LineOptionsPanel')
        if panel:
            panel.update_panel()

    def enabler(self):
        return ctrl.ui.active_edge_style.get('fill', None) is not None

    def getter(self):
        return not ctrl.ui.active_edge_style.get('fill', None)


